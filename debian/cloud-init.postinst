#!/bin/sh

set -e

. /usr/share/debconf/confmodule

set -f # disable pathname expansion
db_capb escape # to support carriage return / multi-line values

debug() {
   [ "${_CI_UPGRADE_DEBUG:-0}" = "0" ] && return 0
   echo "$@" 1>&2 || :
}

update_cfg() {
   # takes filename, header, new object (in yaml), optionally 'remover'
   # and merges new into existing object in filename, and then updates file
   # remover a string that means "delete existing entry"
   python3 -c '
import sys, yaml

def update(src, cand):
    if not (isinstance(src, dict) and isinstance(cand, dict)):
        return cand
    for k, v in cand.items():
        # if the candidate has _ as value, delete source
        if v == REMOVER:
            if k in src:
                del src[k]
            continue
        if k not in src:
            src[k] = v
        else:
            src[k] = update(src[k], v)
    return src

(fname, header, newyaml) = sys.argv[1:4]
REMOVER = object
if len(sys.argv) == 5:
   REMOVER = sys.argv[4]
newcfg = yaml.safe_load(newyaml)

with open(fname, "r") as fp:
    cfg = yaml.safe_load(fp)
if not cfg: cfg = {}

cfg = update(cfg, newcfg)

with open(fname, "w") as fp:
    fp.write(header + "\n")
    fp.write(yaml.dump(cfg))' "$@"
}

fix_1336855() {
  ### Begin fix for LP: 1336855
  # fix issue where cloud-init misidentifies the location of grub and
  # where grub misidentifies the location of the device

  # if cloud-init's grub module did not run, then it did not break anything.
  [ -f /var/lib/cloud/instance/sem/config_grub_dpkg ] || return 0

  # This bug only happened on /dev/xvda devices
  [ -b /dev/xvda ] || return 0

  # we can't fix the system without /proc/cmdline
  [ -r /proc/cmdline ] || return 0

  # Don't do anything unless we have grub
  command -v grub-install > /dev/null || return 0

  # First, identify the kernel device for the parent.
  for parm in $(cat /proc/cmdline); do
       dev=$(echo $parm | awk -F\= '{print$NF}')
       case $parm in
           root=UUID*)  [ -d /dev/disk/by-uuid ] &&
                            root_dev=$(readlink -f /dev/disk/by-uuid/$dev);;
           root=LABEL*) [ -d /dev/disk/by-label ] &&
                            root_dev=$(readlink -f /dev/disk/by-label/$dev);;
           root=/dev*)  [ -d /dev ] &&
                            root_dev=$(readlink -f $dev);;
       esac
       [ -n "$root_dev" ] && break
  done

  # Don't continue if we don't have a root directive
  [ -z "$root_dev" ] && return 0

  # Only deal with simple, cloud-based devices
  case $root_dev in
       /dev/vda*|/dev/xvda*|/dev/sda*) ;;
       *) return 0;;
  esac

  # Make sure that we are not chrooted.
  [ "$(stat -c %d:%i /)" != "$(stat -c %d:%i /proc/1/root/.)" ] && return 0

  # Check if we are in a container, i.e. LXC
  if systemd-detect-virt --quiet --container || lxc-is-container 2>/dev/null; then
      return 0
  fi

  # Find out where grub thinks the root device is. Only continue if
  # grub postinst would install/reinstall grub
  db_get grub-pc/install_devices && grub_cfg_dev=${RET} || return 0
  db_get grub-pc/install_devices_empty && grub_dev_empty=${RET} || return 0

  # Find out the parent device for the root device.
  #     example output: sda/sda1
  block_path=$(udevadm info -q path -n $root_dev | awk '-Fblock/' '{print$NF}') || return 0

  # Extract the parent device name. This works where the device is a block device
  #     example output: /dev/sda
  parent_dev=$(echo $block_path | awk '-F/' '$1 { if ( $1 ) {print"/dev/"$1}}')
  [ -b "${parent_dev}" ] || return 0

  # Do nothing if the device that the grub postinst would install is already used
  [ "$grub_cfg_dev" = "$parent_dev" -o "$grub_cfg_dev" = "$root_dev" ] && return 0

  # If we get here, do the installation
  echo "Reconfiguring grub install device due to mismatch (LP: #1336855)"
  echo "   Grub should use $parent_dev but is configured for $grub_cfg_dev"
  db_set grub-pc/install_devices "$parent_dev"
  grub-install $parent_dev &&
     echo "Reinstalled grub" ||
     echo "WARNING! Unable to fix grub device mismatch. You may be broken."

}

fix_lp1889555() {
    local oldver="$1" last_bad_ver="20.3-2-g371b392c-0ubuntu1"
    dpkg --compare-versions "$oldver" le-nl "$last_bad_ver" || return 0

    # if cloud-init's grub module did not run, then it did not break anything.
    [ -f /var/lib/cloud/instance/sem/config_grub_dpkg ] || return 0

    # Don't do anything unless we have grub
    command -v grub-install > /dev/null || return 0

    # Make sure that we are not chrooted.
    [ "$(stat -c %d:%i /)" != "$(stat -c %d:%i /proc/1/root/.)" ] && return 0

    # Check if we are in a container, i.e. LXC
    if systemd-detect-virt --quiet --container || lxc-is-container 2>/dev/null; then
        return 0
    fi

    # This bug only applies to NVMe devices
    [ -e /dev/nvme0 ] || return 0

    db_get grub-pc/install_devices && grub_cfg_dev=${RET} || return 0

    # If the current setting is not the (potentially-incorrect) default we
    # expect, this implies user intervention so leave things alone
    [ "$grub_cfg_dev" = "/dev/sda" ] || return 0

    correct_idev="$(python3 -c "import logging; from cloudinit.config.cc_grub_dpkg import fetch_idevs; print(fetch_idevs(logging.getLogger()))")" || return 0

    # If correct_idev is the empty string, we failed to determine the correct
    # install device; do nothing
    [ -z "$correct_idev" ] && return 0

    # If the correct_idev is already configured, do nothing
    [ "$grub_cfg_dev" = "$correct_idev" ] && return 0

    echo "Reconfiguring grub install device due to mismatch (LP: #1889555)"
    echo "   grub should use $correct_idev but is configured for $grub_cfg_dev"
    db_set grub-pc/install_devices "$correct_idev"
    db_set grub-pc/install_devices_empty "false"
}

rename_hook_hotplug_udev_rule() {
    # Avoids LP: #1946003 see commit: b519d861aff8b44a0610c176cb34adcbe28df144
    if [ -f /etc/udev/rules.d/10-cloud-init-hook-hotplug.rules ]; then
        mv -f /etc/udev/rules.d/10-cloud-init-hook-hotplug.rules \
            /etc/udev/rules.d/90-cloud-init-hook-hotplug.rules
    fi
}


if [ "$1" = "configure" ]; then
   if db_get cloud-init/datasources; then
      values="$RET"
      if [ "${values#*MaaS}" != "${values}" ]; then
         # if db had old MAAS spelling, fix it.
         values=$(echo "$values" | sed 's,MaaS,MAAS,g')
         db_set cloud-init/datasources "$values"
      fi
      cat > /etc/cloud/cloud.cfg.d/90_dpkg.cfg <<EOF
# to update this file, run dpkg-reconfigure cloud-init
datasource_list: [ $values ]
EOF
   fi

   # fix issue where cloud-init misidentifies the location of grub
   fix_1336855

   fix_lp1889555 "$2"

   rename_hook_hotplug_udev_rule

fi

#DEBHELPER#
