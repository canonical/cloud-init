# Copyright (C) 2025 Clever Cloud
#
# Author: Alexandre Burgoni <alexandre.burgoni@clevercloud.com>
#
# This file is part of cloud-init. See LICENSE file for license information.

import logging
import os
from typing import Dict, Iterable, Mapping

from cloudinit import helpers, subp, util
from cloudinit.distros.package_management.package_manager import (
    PackageManager,
    UninstalledPackages,
)
from cloudinit.settings import PER_ALWAYS, PER_INSTANCE

LOG = logging.getLogger(__name__)

CAVE_COMMAND = ["cave"]

CAVE_UPGRADE_COMMAND = ["resolve", "-c", "world", "-x"]

CAVE_REPOS_SYNC_COMMAND = ["sync"]


class Paludis(PackageManager):
    name = "paludis"

    def __init__(
        self,
        runner: helpers.Runners,
        *,
        cave_command: Optional[list[str]] = None,
        cave_sync_subcommand: Optional[list[str]] = None,
        cave_system_upgrade_subcommand: Optional[list[str]] = None,
    ):
        """Initialize Paludis package manager.

        Args:
            runner: Helper to run commands with specific frequencies
            cave_command: Command to invoke cave (defaults to ["cave"])
            cave_sync_subcommand: Command for syncing repositories
            cave_system_upgrade_subcommand: Command for system upgrade
        """
        super().__init__(runner)

        self.cave_command = cave_command or CAVE_COMMAND
        self.cave_sync_subcommand = (
            cave_sync_subcommand or CAVE_REPOS_SYNC_COMMAND
        )
        self.cave_system_upgrade_subcommand = (
            cave_system_upgrade_subcommand or CAVE_UPGRADE_COMMAND
        )

    @classmethod
    def from_config(cls, runner: helpers.Runners, cfg: Mapping) -> "Paludis":
        return Paludis(
            runner,
            cave_sync_subcommand=cfg.get("cave_sync_subcommand"),
            cave_system_upgrade_subcommand=cfg.get(
                "cave_system_upgrade_subcommand"
            ),
        )

    def update_package_sources(self, *, force=False):
        self.runner.run(
            "update-sources",
            self.run_package_command,
            self.cave_sync_subcommand,
            freq=PER_ALWAYS if force else PER_INSTANCE,
        )

    def available(self):
        return bool(subp.which(self.cave_command[0]))

    def install_packages(self, pkglist: Iterable) -> UninstalledPackages:
        pkglist = util.expand_package_list("%s:%s", list(pkglist))
        self.run_package_command(["resolve"], ["-x", " ".join(pkglist)])
        return []

    def _read_environment_file(self) -> Dict[str, str]:
        """Read environment variables from /etc/environment file.
        This file is generated by eclectic which is a command line in
        Exherbo to manage configuration. Whenever a configuration is updated,
        through eclectic or by a package install, this environment file will
        get updated.

        Returns:
            Dictionary containing environment variables key-pair
        """
        env_vars = {}
        try:
            if os.path.exists("/etc/environment"):
                with open("/etc/environment", "r") as f:
                    for line in f:
                        line = line.strip()
                        if not line or line.startswith("#"):
                            continue
                        if "=" in line:
                            key, value = line.split("=", 1)
                            # Remove quotes if present
                            value = value.strip("\"'")
                            env_vars[key.strip()] = value
                LOG.debug(
                    "Read %d environment variables from /etc/environment",
                    len(env_vars),
                )
            else:
                LOG.debug("/etc/environment file not found")
        except Exception as e:
            LOG.warning("Failed to read /etc/environment: %s", str(e))

        return env_vars

    def run_package_command(self, command, args=None):
        full_command = self.cave_command

        if command == "upgrade":
            command = self.cave_system_upgrade_subcommand
        elif command == "sync":
            command = self.cave_sync_subcommand

        full_command.extend(command)

        if args and isinstance(args, str):
            full_command.append(args)
        elif args and isinstance(args, list):
            full_command.extend(args)

        env_vars = self._read_environment_file()
        # Paludis (package manager) will try to use
        # the HOME to properly function, defining it to /tmp
        # since we do not want to store artifacts into newly created
        # users
        env_vars["HOME"] = "/tmp"

        subp.subp(
            args=full_command,
            capture=False,
            update_env=env_vars,
        )
